# Промышленное программирование

Лекция 1. Работа в командной строке

## Полезные ссылки

* [Репозиторий с материалами курса](https://github.com/dbeliakov/mipt-industrial-programming)
* [The Missing Semester of Your CS Education](https://missing.csail.mit.edu/)
* [Основы BASH. Часть 1](https://habr.com/ru/post/47163/)

## Командная строка

* Вероятно, наиболее гибкий и функциональный способ взаимодействия с PC
* Зачастую, единственный способ (например, на удаленных серверах)
* Почти для любого действия есть утилиты, которые можно комбинировать, создавая сценарии любой сложности
* В некоторых случаях необходимая функциональность случайно или намеренно скрыта от UI пользователей

## Командная строка

* Взаимодействовать с PR через командную строку можно посредством Терминала
* Для macOS есть отличный сторонний терминал [iTerm2](https://iterm2.com/)
* Текст, подаваемый на вход терминалу, отправляется в командную оболочку, или shell
* Наиболее популярные оболочки: Bourne again shell (Bash), Z shell (Zsh), Friendly interactive shell (Fish), ...
* У каждой оболочки есть свои особенности, но в основных задачах они все похожи

## Shell

* После открытия терминала (и перед вводом каждой команды) выводится prompt
* По умолчанию он отображает текущую директорию, имя хоста и статус пользователя (root или нет)
* Prompt можно сконфигурировать под себя, и он будет отображать полезную информацию (статус последней команды, какая сейчас ветка в git, production или testing окружение в ssh и т.д.)
* После prompt'а можно ввести текст, который будет проинтерпретирован командной оболочкой (и результат отобразится в терминале)

## Shell

* Самая базовая из команд - запуск какой-либо программы
* Программа может принимать набор аргументов - обычно это "слова", разделенные пробелами
* Если аргумент содержит пробелы, то можно обернуть его в "" или '', либо же экранировать пробел через \
* Программа может быть запущена по абсолютному или относительному пути (большинство утилит живут в `*/bin/` в системе, но это не обязательное требование)
* Также программа для запуска может быть найдена по путям, прописанным в `$PATH`

## Навигация

* На Linux и macOS пути разделяются `/` и начинаются с корневого каталога `/`, в Windows - `\` и диска (`C:\`) соответственно
* В дальнейшем все будем рассматривать для Linux или macOS
* Пути, начинающиеся с `/`- абсолютные, с `./` - относительные (для текущей директории)
* Псевдодиректории: `.` - текущая, `..` - родительская
* Для перехода между директориями - `cd <PATH>`, для вывода текущей директории - `pwd`
* Обычно программы работают с текущей директорией, если путь не явный (например, `touch new_file.txt`)

## Навигация

* Вывести список файлов и директорий можно с помощью `ls`
* Большинство программ принимают аргументы, начинающиеся с `-` (или `--`), которые обрабатываются как флаги или непозиционные аргументы (например, `ls -la`)
* У каждого объекта ФС есть права доступа, в виде `rwx|rwx|rwx` - пользователь, группа и остальные. Для изменения прав - `chmod`
* Другие полезные команды - `mv`, `cp`, `mkdir`, `rm`, `touch`, `cat`, `less`, `head`, `tail` (особенно `tail -f`)

## Успешное и неуспешное завершение процесса

* Помимо вывода, программа при завершении передает код возврата
* По соглашению 0 - успешное выполнение, иначе (>0) - неуспешное
* Узнать код возврата после выполнения команды можно через `echo $?`
* Код возврата позволяет "очень грубо" сообщить о результате выполнения программы

## Перенаправление ввода/вывода

* По умолчанию, ввод (stdin) и вывод (stdout) программы поступают из терминала и в терминал
* С помощью синтаксиса `< file` and `> file` можно переопределять stdin и stdout файлами
* При использовании `>` файл будет перезаписан, но можно использовать `>>` для дописывания в конец
* Можно указать дескриптор: `1>out.txt` `2>err.txt`; комбинировать потоки: `2>&1`
* Кроме этого, через `|` (pipe) можно связать stdout одной программы с stdin другой
* Это позволяет строить "конвееры" по обработке данных без непосредственно программирования

## Ctrl-C и Ctrl-D

* Для того, чтобы завершить работающий процесс, можно нажать `Ctrl-C` (или более жестоко `Ctrl-Z`)
* Если ввод идет с клавиатуры, то `Ctrl-D` позволяет передать сигнал, что ввод закончен (как `EOF` для файлов)
* В том числе, при нажатии `Ctrl-D` внутри командной оболочки она закончит свое выполнение

## Установка пакетов

* Большинство программ на Linux и много консольных программ в macOS устанавливаются через менеджер пакетов
* Ubuntu - `apt-get update`, `apt-get install ...`, macOS - `brew install ...`
* Кроме этого, есть специфичные для ЯП способы получения пакетов, например `pip`, `npm`, `go get ...` и т.д.
